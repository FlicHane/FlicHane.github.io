<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bean Configuration注解详解</title>
    <url>/2024/11/12/@Bean%20@Configuration%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>这个配置类里的<code>@Bean</code>注解方法会在</strong>Spring容器初始化时<strong>自动执行</strong>。</p>
<p>具体来说：</p>
<ol>
<li><p>**<code>@Configuration</code>**：表示这是一个配置类，Spring会在启动时读取这个类并处理其中的<code>@Bean</code>注解的方法。</p>
</li>
<li><p>**<code>@Bean</code>**：告诉Spring这个方法的返回值是一个Spring管理的bean，会被注册到Spring的IOC容器中。</p>
</li>
</ol>
<p>因此，在应用启动的时候，Spring会扫描到（用的是”具体细节“内用到的例子）<code>RedisConfiguration</code>类并调用<code>redisTemplate()</code>方法，创建<code>RedisTemplate</code>对象，并将其注册到Spring容器中，供其他地方使用。</p>
<p>所以，这个方法会在程序启动时自动执行，<strong>不用手动调用</strong>。</p>
<h1 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a><span style="background:#ff4d4f">更多细节</span></h1><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板&quot;</span>);  </span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();  </span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());  </span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);  </span><br><span class="line">        <span class="keyword">return</span> redisTemplate;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-Spring容器的工作原理"><a href="#1-Spring容器的工作原理" class="headerlink" title="1. Spring容器的工作原理"></a>1. <strong>Spring容器的工作原理</strong></h3><p>Spring的<strong>IOC容器</strong>，即控制反转容器，负责管理对象的创建、生命周期、依赖注入等，确保对象之间的关系和依赖性都被正确处理。在Spring中，容器的核心是<code>ApplicationContext</code>，它是<strong>BeanFactory</strong>的超集。</p>
<h3 id="2-Bean方法的执行流程"><a href="#2-Bean方法的执行流程" class="headerlink" title="2. @Bean方法的执行流程"></a>2. <strong><code>@Bean</code>方法的执行流程</strong></h3><p>当你在配置类中定义了<code>@Bean</code>注解的方法，Spring容器会在<strong>应用启动时</strong>扫描到这个方法，并通过反射调用它。调用这个方法时，Spring并不会立即执行方法体里的内容，而是会执行以下步骤：</p>
<ul>
<li><p><strong>创建Bean实例</strong>：Spring调用<code>redisTemplate()</code>方法，并获取它返回的<code>RedisTemplate</code>对象。<strong>这时，<code>RedisTemplate</code>对象被创建出来</strong>。</p>
</li>
<li><p><strong>管理Bean的生命周期</strong>：Spring会将这个<code>RedisTemplate</code>实例放入IOC容器中，成为一个可管理的<strong>Bean</strong>。容器会管理这个对象的生命周期，比如初始化、依赖注入、销毁等。</p>
</li>
</ul>
<h3 id="3-Bean的依赖注入"><a href="#3-Bean的依赖注入" class="headerlink" title="3. Bean的依赖注入"></a>3. <strong>Bean的依赖注入</strong></h3><ul>
<li><p><strong>自动注入</strong>：在<code>redisTemplate()</code>方法里，<code>RedisConnectionFactory</code>是作为方法参数传入的。Spring会在容器中查找<strong>合适的<code>RedisConnectionFactory</code> Bean</strong>，并自动注入到<code>redisTemplate()</code>方法中。</p>
</li>
<li><p><strong>传递依赖</strong>：Spring会首先实例化<code>RedisConnectionFactory</code>，然后把它作为依赖传递给<code>redisTemplate()</code>，从而完成整个Bean的创建过程。</p>
</li>
</ul>
<h3 id="4-实例化和注册到容器"><a href="#4-实例化和注册到容器" class="headerlink" title="4. 实例化和注册到容器"></a>4. <strong>实例化和注册到容器</strong></h3><ul>
<li>当<code>redisTemplate()</code>方法被调用时，<code>RedisTemplate</code>对象已经创建并返回给Spring。</li>
<li><strong>Spring将<code>RedisTemplate</code>实例注册到容器</strong>，这个Bean的名字就是方法名——<code>redisTemplate</code>，你可以在其他地方通过<code>@Autowired</code>或者<code>@Qualifier</code>来注入它。</li>
</ul>
<h3 id="5-执行时机"><a href="#5-执行时机" class="headerlink" title="5. 执行时机"></a>5. <strong>执行时机</strong></h3><ul>
<li><p><strong>容器启动时</strong>，Spring会扫描到标有<code>@Configuration</code>和<code>@Bean</code>的类。此时，Spring容器会调用所有<code>@Bean</code>注解的方法，创建这些Bean并注册到容器中。你不需要手动调用<code>redisTemplate()</code>，Spring自动帮你处理。</p>
</li>
<li><p><strong><code>@Bean</code>方法调用顺序</strong>：如果有多个<code>@Bean</code>注解方法，Spring会按照方法定义的顺序来调用它们，保证依赖关系正确。</p>
</li>
</ul>
<h3 id="6-为什么要使用-Bean和-Configuration？"><a href="#6-为什么要使用-Bean和-Configuration？" class="headerlink" title="6. 为什么要使用@Bean和@Configuration？"></a>6. <strong>为什么要使用<code>@Bean</code>和<code>@Configuration</code>？</strong></h3><ul>
<li><p><strong>解耦和集中管理配置</strong>：使用<code>@Configuration</code>注解的类可以集中管理你的配置，避免把配置散布到代码的各个地方。这样也更容易进行单元测试和修改配置。</p>
</li>
<li><p><strong>灵活控制Bean的创建</strong>：使用<code>@Bean</code>方法，你可以对Bean的创建过程进行精确控制。比如你可以在<code>@Bean</code>方法里添加日志、配置条件等，而这些<code>@Bean</code>方法会在容器初始化时执行。</p>
</li>
</ul>
<h3 id="7-容器启动的步骤概览"><a href="#7-容器启动的步骤概览" class="headerlink" title="7. 容器启动的步骤概览"></a>7. <strong>容器启动的步骤概览</strong></h3><ol>
<li><strong>扫描配置类</strong>：Spring扫描所有带有<code>@Configuration</code>注解的类，找到其中的<code>@Bean</code>方法。</li>
<li><strong>调用<code>@Bean</code>方法</strong>：Spring通过<font color="#d83931">反射</font>调用<code>@Bean</code>标记的方法，创建这些Bean。</li>
<li><strong>依赖注入</strong>：Spring会解析<code>@Autowired</code>、<code>@Qualifier</code>等注解，自动注入Bean的依赖。</li>
<li><strong>注册到容器</strong>：创建好的Bean被注册到容器中，可以通过<code>@Autowired</code>或者其他方式进行注入使用。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>容器在应用启动时会自动识别和调用带有<code>@Bean</code>注解的方法，创建相应的对象，并管理它们的生命周期和依赖注入。你通过<code>@Bean</code>定义的<code>RedisTemplate</code>，Spring会帮你自动创建并注入所需的依赖项（比如<code>RedisConnectionFactory</code>），然后将其注册到IOC容器中供其他组件使用。这种方式使得配置类能更灵活地控制Bean的创建过程，同时保持代码的简洁和模块化。</p>
]]></content>
      <tags>
        <tag>java注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache POI</title>
    <url>/2024/11/17/Apache-POI/</url>
    <content><![CDATA[<p>Apache POI是处理Office文档的Java库，主要用来读写Excel、Word、PowerPoint文件。以下是个简单示例，用来操作Excel。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>先加上Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().  </span><br><span class="line">        getResourceAsStream(<span class="string">&quot;ExcelTemplate/运营数据报表模板.xlsx&quot;</span>);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(resourceAsStream);  </span><br><span class="line">    <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.getSheetAt(<span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//填入数据    </span></span><br><span class="line">    sheet.getRow(<span class="number">0</span>).getCell(<span class="number">0</span>).setCellValue(<span class="string">&quot;你好&quot;</span>);  </span><br><span class="line">    <span class="comment">//导出文件  </span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> httpServletResponse.getOutputStream();  </span><br><span class="line">    excel.write(outputStream);  </span><br><span class="line">	<span class="comment">//关闭流</span></span><br><span class="line">    outputStream.close();  </span><br><span class="line">    resourceAsStream.close();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><code>.xls</code>文件用<code>HSSFWorkbook</code>，<code>.xlsx</code>用<code>XSSFWorkbook</code>。</li>
<li>文件操作注意关闭流。</li>
<li>数据类型处理时，检查<code>CellType</code>，避免类型转换错误。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo和GitHub部署静态网站</title>
    <url>/2024/11/10/How-to-deploy-a-static-website-with-Hexo-and-GitHub/</url>
    <content><![CDATA[<p>我使用的模板是hexo上的keep</p>
<h3 id="1-安装-Node-js-和-Hexo"><a href="#1-安装-Node-js-和-Hexo" class="headerlink" title="1. 安装 Node.js 和 Hexo"></a>1. 安装 Node.js 和 Hexo</h3><ul>
<li><p><strong>安装 Node.js</strong>：去 <a class="link"   href="https://nodejs.org/" >Node.js官网<i class="fas fa-external-link-alt"></i></a> 下载并安装 Node.js（装完会自动带上 npm）。</p>
</li>
<li><p><strong>安装 Hexo</strong>：打开终端（先win+R，输入cmd后回车），运行以下命令来全局安装 Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-初始化-Hexo-项目"><a href="#2-初始化-Hexo-项目" class="headerlink" title="2. 初始化 Hexo 项目"></a>2. 初始化 Hexo 项目</h3><ul>
<li><p>选择一个文件夹，作为你的网站项目目录。</p>
</li>
<li><p>进入这个文件夹，用 Hexo 初始化项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init 你的项目名称</span><br><span class="line"><span class="built_in">cd</span> 你的项目名称</span><br><span class="line">npm install  <span class="comment"># 安装项目依赖</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>如果hexo init blog 卡住</strong></p>
<p>​    此小节引用于：<a class="link"   href="https://blog.csdn.net/f6619082/article/details/109193251" >https://blog.csdn.net/f6619082/article/details/109193251<i class="fas fa-external-link-alt"></i></a></p>
<p>​    替换成以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/weilining/hexo-starter.git blog</span><br><span class="line">   <span class="built_in">cd</span> blog</span><br><span class="line">   git submodule init</span><br><span class="line">   git submodule update</span><br><span class="line">   npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org</span><br><span class="line">   npm i	</span><br></pre></td></tr></table></figure>



<h3 id="3-创建内容"><a href="#3-创建内容" class="headerlink" title="3. 创建内容"></a>3. 创建内容</h3><ul>
<li>选择网站模板<br>可以到hexo官网找模板，点击模板链接到GitHub，里面会有网站模板应该如何部署的介绍<br>部署好模板之后就可以跟着介绍自定义自己的网站</li>
</ul>
<h3 id="4-配置-GitHub-Pages-部署"><a href="#4-配置-GitHub-Pages-部署" class="headerlink" title="4. 配置 GitHub Pages 部署"></a>4. 配置 GitHub Pages 部署</h3><ul>
<li><p><strong>安装 GitHub 部署插件</strong>：<br>这个插件可以把生成的public文件上传到GitHub<br> public文件由hexo deploy命令生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 <code>_config.yml</code> 文件</strong>：<br>打开项目根目录下的 <code>_config.yml</code>，在底部找到 <code>deploy</code> 配置，填入 GitHub 仓库信息：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/你的GitHub用户名/你的仓库名.git</span><br><span class="line">  branch: master  <span class="comment"># 如果用的主分支是 master，就写 master，不是的话改成对应分支</span></span><br></pre></td></tr></table></figure>

<h3 id="5-本地预览"><a href="#5-本地预览" class="headerlink" title="5. 本地预览"></a>5. 本地预览</h3><ul>
<li><p>在本地生成静态文件并预览效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>打开浏览器访问 <code>http://localhost:4000</code>，看看网站效果。</p>
</li>
</ul>
<h3 id="6-部署到-GitHub-Pages"><a href="#6-部署到-GitHub-Pages" class="headerlink" title="6. 部署到 GitHub Pages"></a>6. 部署到 GitHub Pages</h3><ul>
<li><p>生成并部署到 GitHub Pages：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean     <span class="comment"># 清理旧文件，确保是最新内容</span></span><br><span class="line">hexo generate  <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo deploy    <span class="comment"># 部署到 GitHub</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有报错，访问 <code>https://你的GitHub用户名.github.io</code> 就可以看到你的 Hexo 网站上线了。</p>
</li>
</ul>
<h3 id="7-更新和再次部署"><a href="#7-更新和再次部署" class="headerlink" title="7. 更新和再次部署"></a>7. 更新和再次部署</h3><p>每次修改内容或发布新文章时，重复以下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>就这些，全流程下来网站就部署在 GitHub Pages 上了。</p>
<p>hexo generate指令等价于hexo g</p>
<p>hexo server指令等价于hexo s</p>
]]></content>
      <tags>
        <tag>buildWebsite</tag>
      </tags>
  </entry>
  <entry>
    <title>创建静态网站时可能会遇到的问题</title>
    <url>/2024/11/11/Many-question-in-developing-static-website/</url>
    <content><![CDATA[<h1 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [post] shit</span><br></pre></td></tr></table></figure>

<p><span style="background:#ff4d4f">注意</span>：如果<em>文件名</em>为中文时，hexo g 指令无法正常生成网页文件，可以试试把电脑系统的编码模式设置为UTF-8</p>
<h1 id="title中不允许存在-字符"><a href="#title中不允许存在-字符" class="headerlink" title="title中不允许存在@字符"></a>title中不允许存在@字符</h1><p><img   src="https://flichane.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.6wqqytzg3d.webp"  alt="none"></p>
]]></content>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的用法</title>
    <url>/2024/11/17/redis%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><img   src="https://flichane.github.io/picx-images-hosting/redis%E7%9A%84%E7%94%A8%E6%B3%95.pfd5ng6te.webp" ></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>中文文件名测试</title>
    <url>/2024/11/11/%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>哈哈哈成功了，留个纪念</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的数据类型</title>
    <url>/2024/11/17/redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><img   src="https://flichane.github.io/picx-images-hosting/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.4uayhrb3ks.png" ></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>各种概念之间的联系</title>
    <url>/2024/11/17/%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>这些技术和工具大致可以分为 <strong>框架</strong>、<strong>工具</strong> 和 <strong>服务</strong>，它们在功能上有不同侧重，也可以相互配合使用。下面简单梳理它们的区别和联系。</p>
<hr>
<h3 id="1-Spring-Boot"><a href="#1-Spring-Boot" class="headerlink" title="1. Spring Boot"></a><strong>1. Spring Boot</strong></h3><ul>
<li><strong>类型</strong>：框架。</li>
<li><strong>用途</strong>：快速构建基于 Spring 的独立应用。</li>
<li><strong>特点</strong>：简化配置，通过自动化配置减少开发复杂度。支持微服务架构，内置 Tomcat。</li>
<li><strong>联系</strong>：<ul>
<li><strong>Tomcat</strong>：Spring Boot 默认内嵌 Tomcat 作为应用容器。</li>
<li><strong>MyBatis/MyBatis-Plus</strong>：可作为持久层框架，与 Spring Boot 无缝集成。</li>
<li><strong>Redis</strong>：可通过 Spring Data Redis 轻松整合 Redis。</li>
<li><strong>Maven</strong>：管理 Spring Boot 项目依赖和构建。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2. Tomcat"></a><strong>2. Tomcat</strong></h3><ul>
<li><strong>类型</strong>：Web 服务器/Servlet 容器。</li>
<li><strong>用途</strong>：运行 Java Web 应用，提供 Servlet 和 JSP 支持。</li>
<li><strong>特点</strong>：轻量级，运行 Java EE 的部分功能（主要是 Web 层）。</li>
<li><strong>联系</strong>：<ul>
<li><strong>Spring Boot</strong>：Tomcat 是 Spring Boot 默认的内置 Web 容器。</li>
<li><strong>Servlet</strong>：Tomcat 运行的核心是 Servlet。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3. Nginx"></a><strong>3. Nginx</strong></h3><ul>
<li><strong>类型</strong>：反向代理服务器/Web 服务器。</li>
<li><strong>用途</strong>：处理高并发请求，负载均衡，反向代理，静态资源服务。</li>
<li><strong>特点</strong>：轻量、高效，适用于高并发场景。</li>
<li><strong>联系</strong>：<ul>
<li>通常将 <strong>Nginx</strong> 放在前端处理静态资源、请求分发，Spring Boot 后端处理业务逻辑。</li>
<li>可以与 <strong>Tomcat</strong> 配合，Nginx 作为反向代理，Tomcat 处理 Java Web 请求。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-MyBatis"><a href="#4-MyBatis" class="headerlink" title="4. MyBatis"></a><strong>4. MyBatis</strong></h3><ul>
<li><strong>类型</strong>：持久层框架。</li>
<li><strong>用途</strong>：简化数据库操作，提供 SQL 映射和动态 SQL 支持。</li>
<li><strong>特点</strong>：轻量灵活，注重 SQL 的可控性。</li>
<li><strong>联系</strong>：<ul>
<li>常与 <strong>Spring Boot</strong> 整合，用于操作数据库。</li>
<li><strong>MyBatis</strong> 的 XML 映射文件和注解配置让开发者能直接书写 SQL，方便复杂查询。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-MyBatis-Plus"><a href="#5-MyBatis-Plus" class="headerlink" title="5. MyBatis-Plus"></a><strong>5. MyBatis-Plus</strong></h3><ul>
<li><strong>类型</strong>：MyBatis 的增强版。</li>
<li><strong>用途</strong>：简化 MyBatis 开发，提供更丰富的功能，如 CRUD 快速开发。</li>
<li><strong>特点</strong>：开箱即用，内置大量工具方法（如分页、自动生成代码）。</li>
<li><strong>联系</strong>：<ul>
<li>基于 <strong>MyBatis</strong> 开发，与 Spring Boot 配合非常常见。</li>
<li>在 MyBatis 基础上减少重复代码，提升开发效率。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6. Redis"></a><strong>6. Redis</strong></h3><ul>
<li><strong>类型</strong>：缓存数据库。</li>
<li><strong>用途</strong>：存储数据（键值对），用于缓存、高速数据访问、分布式锁等。</li>
<li><strong>特点</strong>：基于内存，读写速度快，支持丰富的数据类型（如字符串、哈希、列表等）。</li>
<li><strong>联系</strong>：<ul>
<li><strong>Spring Boot</strong> 提供对 Redis 的集成（通过 Spring Data Redis）。</li>
<li>可以与 MyBatis/MyBatis-Plus 结合，缓存查询结果，提高性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-Maven"><a href="#7-Maven" class="headerlink" title="7. Maven"></a><strong>7. Maven</strong></h3><ul>
<li><strong>类型</strong>：构建工具。</li>
<li><strong>用途</strong>：管理项目依赖、构建和打包，简化项目配置和发布。</li>
<li><strong>特点</strong>：基于 POM 文件的依赖管理，支持生命周期。</li>
<li><strong>联系</strong>：<ul>
<li><strong>Spring Boot</strong>：通过 Maven 管理依赖和构建项目。</li>
<li>其他工具（如 MyBatis、MyBatis-Plus）大多通过 Maven 引入。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-Servlet"><a href="#8-Servlet" class="headerlink" title="8. Servlet"></a><strong>8. Servlet</strong></h3><ul>
<li><strong>类型</strong>：Java EE 核心组件。</li>
<li><strong>用途</strong>：处理 HTTP 请求和响应，是 Web 应用的核心基础。</li>
<li><strong>特点</strong>：低级 API，直接处理请求和响应。</li>
<li><strong>联系</strong>：<ul>
<li><strong>Tomcat</strong>：Servlet 容器，运行 Servlet 应用。</li>
<li><strong>Spring Boot</strong>：基于 Servlet 封装和扩展，提供更高级的功能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：它们的关系"><a href="#总结：它们的关系" class="headerlink" title="总结：它们的关系"></a><strong>总结：它们的关系</strong></h3><ul>
<li><strong>分工明确</strong>：每个工具和技术都有其专注的领域。</li>
<li><strong>相互配合</strong>：<ul>
<li>Nginx（前端代理）→ Tomcat（后端容器）→ Spring Boot（逻辑层）。</li>
<li>Spring Boot 整合 MyBatis 或 MyBatis-Plus 操作数据库。</li>
<li>Redis 提供缓存支持，加速数据访问。</li>
<li>Maven 负责统一管理项目依赖，打包和发布。</li>
<li>Servlet 是底层支撑技术，Spring Boot 和 Tomcat 基于它构建。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>图片上传测试</title>
    <url>/2024/11/12/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<img     src="https://github.com/FlicHane/picx-images-hosting/raw/master/头像.7p3mgj28tl.webp"   alt="头像"  >
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2024/11/17/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="what-it-is"><a href="#what-it-is" class="headerlink" title="what it is"></a><span style="background:#ff4d4f">what it is</span></h1><p><strong>序列化</strong>就是把对象转换成一串字节（二进制数据：“0010101”），这样对象可以存到文件里、数据库里，或者通过网络传输。<br>等需要用的时候，再把字节流转回对象，这叫<strong>反序列化</strong>。</p>
<p>在Java里，想让类支持序列化，你得让它实现<code>Serializable</code>接口，没别的要求，直接上就行。<br>这样一来，Java会帮你把对象状态给“拍个快照”，方便以后拿出来用。</p>
<h1 id="question"><a href="#question" class="headerlink" title="question"></a><span style="background:#ff4d4f">question</span></h1><h3 id="为什么在写redis模板配置类的时候需要设置key的序列化器"><a href="#为什么在写redis模板配置类的时候需要设置key的序列化器" class="headerlink" title="为什么在写redis模板配置类的时候需要设置key的序列化器"></a>为什么在写redis模板配置类的时候需要设置key的序列化器</h3><p>Redis里的key和value都是存<strong>储在内存里的数据</strong>，但本质上都是<strong>字节</strong>。所以，想在Redis里存对象（包括Java的各种复杂数据类型）的时候，就得<strong>序列化</strong>，不然Redis根本识别不了你这堆东西。</p>
<p>设置key的序列化器，主要就是为了<strong>保证Redis能读懂和还原key</strong>。不然一堆乱码，查个数据都查不到，key直接废了。</p>
<p>在Spring框架里，比如用<code>StringRedisSerializer</code>来序列化key，能保证存进去的和读出来的是一样的格式。这样查询就方便多了，不会出什么“找不到key”的蠢事儿。</p>
<h3 id="序列化后的数据的具体形式是什么"><a href="#序列化后的数据的具体形式是什么" class="headerlink" title="序列化后的数据的具体形式是什么"></a>序列化后的数据的具体形式是什么</h3><p>字节的具体形式，就是对象被转成<strong>二进制数据流</strong>的那种形式。</p>
<p>Java里用默认的<code>ObjectOutputStream</code>序列化时，数据会按特定的二进制协议来编码，所以你直接去看的话，是一大堆“1010…”**的二进制。这些字节就是对象的“快照”，别人看不懂，但Java反序列化能还原它。</p>
<p>当然，用<code>JSON</code>或<code>XML</code>序列化的话，就是字符串格式，但底层传输时还是转成字节流。</p>
]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
</search>
